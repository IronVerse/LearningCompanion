// api/services/answerService.js
// Service responsible for grading student answers, recording
// attempts in the database and returning feedback for incorrect
// responses.  It uses the AnswerEvaluatorAgent (a language model)
// to assess correctness and generate helpful explanations and hints.

import { query } from '../db/pool.js';
import AnswerEvaluatorAgent from '../agents/AnswerEvaluatorAgent.js';

class AnswerService {
  /**
   * Grade a batch of answers for a user.  Each answer is evaluated
   * against the correct answer stored in the questions table and
   * persisted as an attempt.  The method returns a list of
   * incorrectly answered questions with feedback generated by
   * AnswerEvaluatorAgent.
   *
   * @param {number} userId - The user ID
   * @param {Array<{questionId:number, optionId:number}>} answers - The submitted answers
   * @returns {Promise<{incorrect: Array<{questionId:number, feedback:string}>}>}
   */
  async gradeAnswers(userId, answers) {
    const incorrect = [];
    for (const ans of answers) {
      const { questionId, optionId } = ans;
      // Fetch the question stem and correct answer from DB
      const qRes = await query(
        'SELECT stem_markdown, solution_text FROM questions WHERE question_id = $1',
        [questionId]
      );
      if (qRes.rows.length === 0) continue; // skip if question not found
      const { stem_markdown: stem, solution_text: correctAnswer } = qRes.rows[0];
      // Fetch the student's selected option text
      let selectedAnswer = null;
      if (optionId) {
        const oRes = await query(
          'SELECT body_markdown FROM options WHERE option_id = $1 AND question_id = $2',
          [optionId, questionId]
        );
        if (oRes.rows.length > 0) {
          selectedAnswer = oRes.rows[0].body_markdown;
        }
      }
      // Use the evaluator agent to assess correctness and get feedback
      let evaluation;
      try {
        const evalResponse = await AnswerEvaluatorAgent.evaluate(stem, selectedAnswer || '', correctAnswer);
        // The evaluator may wrap its JSON in markdown code fences.  Remove any code fence markers and
        // surrounding whitespace before parsing.  This makes parsing robust to responses like
        // ```json\n{"result":"incorrect","feedback":"..."}\n```
        let cleaned = evalResponse;
        if (typeof cleaned === 'string') {
          cleaned = cleaned.replace(/```json|```/g, '').trim();
        }
        evaluation = JSON.parse(cleaned);
      } catch (err) {
        // If parsing still fails, default to an incorrect result with generic feedback
        evaluation = { result: 'incorrect', feedback: 'There was an error evaluating this answer.' };
      }
      const isCorrect = evaluation.result && evaluation.result.toLowerCase() === 'correct';
      const score = isCorrect ? 1 : 0;
      // Record the attempt
      const attemptRes = await query(
        'INSERT INTO attempts (user_id, question_id, submitted_at, is_correct, score) VALUES ($1, $2, now(), $3, $4) RETURNING attempt_id',
        [userId, questionId, isCorrect, score]
      );
      const attemptId = attemptRes.rows[0].attempt_id;
      // Record which options were selected for this attempt
      if (optionId) {
        await query(
          'INSERT INTO attempt_selected_options (attempt_id, option_id) VALUES ($1, $2)',
          [attemptId, optionId]
        );
      }
      // Update user_skill_mastery for all topics associated with this question.  We fetch
      // the topic IDs from question_topics, then adjust the student's mastery up or
      // down depending on correctness.  Each mastery score is bounded between 0 and 1.
      const topicsRes = await query(
        'SELECT topic_id FROM question_topics WHERE question_id = $1',
        [questionId]
      );
      const topicIds = topicsRes.rows.map(r => r.topic_id);
      for (const tId of topicIds) {
        // Retrieve existing mastery or use default 0.3
        const mRes = await query(
          'SELECT p_mastery FROM user_skill_mastery WHERE user_id = $1 AND topic_id = $2',
          [userId, tId]
        );
        let current = 0.3;
        if (mRes.rows.length > 0) {
          const val = parseFloat(mRes.rows[0].p_mastery);
          if (!isNaN(val)) current = val;
        }
        // Simple update rule: increase mastery by 0.1 when correct, decrease when incorrect
        let newMastery;
        if (isCorrect) {
          newMastery = Math.min(1.0, current + 0.1);
        } else {
          newMastery = Math.max(0.0, current - 0.1);
        }
        // Upsert into user_skill_mastery
        await query(
          'INSERT INTO user_skill_mastery (user_id, topic_id, p_mastery, updated_at) VALUES ($1, $2, $3, now())\n           ON CONFLICT (user_id, topic_id) DO UPDATE SET p_mastery = $3, updated_at = now()',
          [userId, tId, newMastery]
        );
      }
      // If incorrect, collect feedback for the response
      if (!isCorrect) {
        incorrect.push({ questionId, feedback: evaluation.feedback });
      }
    }
    return { incorrect };
  }
}

export default new AnswerService();
// api/services/answerService.js
// Service responsible for grading student answers, recording
// attempts in the database and returning feedback for incorrect
// responses.  It uses the AnswerEvaluatorAgent (a language model)
// to assess correctness and generate helpful explanations and hints.

import { query } from '../db/pool.js';
import AnswerEvaluatorAgent from '../agents/AnswerEvaluatorAgent.js';

class AnswerService {
  /**
   * Grade a batch of answers for a user.  Each answer is evaluated
   * against the correct answer stored in the questions table and
   * persisted as an attempt.  The method returns a list of
   * incorrectly answered questions with feedback generated by
   * AnswerEvaluatorAgent.
   *
   * @param {number} userId - The user ID
   * @param {Array<{questionId:number, optionId:number}>} answers - The submitted answers
   * @returns {Promise<{incorrect: Array<{questionId:number, feedback:string}>}>}
   */
  async gradeAnswers(userId, answers) {
    const incorrect = [];
    for (const ans of answers) {
      const { questionId, optionId } = ans;
      // Fetch the question stem and correct answer from DB
      const qRes = await query(
        'SELECT stem_markdown, solution_text FROM questions WHERE question_id = $1',
        [questionId]
      );
      if (qRes.rows.length === 0) continue; // skip if question not found
      const { stem_markdown: stem, solution_text: correctAnswer } = qRes.rows[0];
      // Fetch the student's selected option text
      let selectedAnswer = null;
      if (optionId) {
        const oRes = await query(
          'SELECT body_markdown FROM options WHERE option_id = $1 AND question_id = $2',
          [optionId, questionId]
        );
        if (oRes.rows.length > 0) {
          selectedAnswer = oRes.rows[0].body_markdown;
        }
      }
      // Use the evaluator agent to assess correctness and get feedback
      let evaluation;
      try {
        const evalResponse = await AnswerEvaluatorAgent.evaluate(stem, selectedAnswer || '', correctAnswer);
        evaluation = JSON.parse(evalResponse);
      } catch (err) {
        // In the unlikely event that parsing fails, treat as incorrect with generic feedback
        evaluation = { result: 'incorrect', feedback: 'There was an error evaluating this answer.' };
      }
      const isCorrect = evaluation.result && evaluation.result.toLowerCase() === 'correct';
      const score = isCorrect ? 1 : 0;
      // Record the attempt
      const attemptRes = await query(
        'INSERT INTO attempts (user_id, question_id, submitted_at, is_correct, score) VALUES ($1, $2, now(), $3, $4) RETURNING attempt_id',
        [userId, questionId, isCorrect, score]
      );
      const attemptId = attemptRes.rows[0].attempt_id;
      // Record which options were selected for this attempt
      if (optionId) {
        await query(
          'INSERT INTO attempt_selected_options (attempt_id, option_id) VALUES ($1, $2)',
          [attemptId, optionId]
        );
      }
      // If incorrect, collect feedback for the response
      if (!isCorrect) {
        incorrect.push({ questionId, feedback: evaluation.feedback });
      }
    }
    return { incorrect };
  }
}

export default new AnswerService();